import { useState, useRef, useContext } from "react"
import { DataDisplayFn } from "./dbDataDisplay";


// escapes special sql chracters in identifiers
function escapeSQLCharacters(text: string): string {
  let escapedText = text.replace(/"/g, '""');
  if ((/[\[\]()*\s\.\$"+-/\\,:;]/).test(text)) { // text contains sql special characters
    escapedText = `"${escapedText}"`;
  }
  return escapedText;
}

function getDefaultValue(text: string, columnType: string) {
  if (["character", "character varying", "text"].includes(columnType)) {
    return "$$" + text + "$$"
  }
  return text
}

function DataTypeOptions(){
  let postgreSqlTypes = [
    "bigint", "bit", "bit varying", "boolean", "char", "character varying", "character",
    "varchar", "date", "double precision", "integer", "numeric", "decimal", "domain types",
    "real", "smallint", "timestamp", "smallserial", "serial", "bigserial", "line segments",
    "text", "bytea", "time", "interval", "timestamptz", "enum", "points", "lines", "boxes",
    "paths", "polygons", "circles", "inet", "cidr", "macaddr", "macaddr8", "tsquery", "oids", "money",
    "uuid", "xml", "json", "jsonb", "Array",  "tsvector", "composite types", "ranges", "pg_lsn", "pseudo types"
  ]
  let htmlOptionElems = postgreSqlTypes.map((option) => <option key={option}>{option}</option>)
  return (
    <>
      {htmlOptionElems}
    </>
  )
}

function getColumnDetails(container: HTMLDivElement) { // escape user input
  const formEntries:any = Object();
  const targetValues = ["column-name", "data-type", "constraints", "char-length"]
  // should be documented that you have auto escaped identifiers and strings

  for (let i=0; i<container.children.length; i++) {
    let formControl = container.children.item(i) as HTMLInputElement;
    if (formControl.name === "column-name") {
      formControl.value = escapeSQLCharacters(formControl.value)
    }
    if (formControl.name === "default-value" && formControl.value.trim()) {
      formEntries[formControl.name] = ` DEFAULT ${getDefaultValue(formControl.value, formControl.name)}`
    }else if (formControl.name && targetValues.includes(formControl.name)) {
      if (formControl.value) { // trim it first?
        formEntries[formControl.name] = ' ' + formControl.value;
      }else formEntries[formControl.name] = "";
    }
  }

  if (formEntries["data-type"] === " character" || formEntries["data-type"] === " character varying") {
    let charLength = formEntries["char-length"].trim()
    formEntries["data-type"] += (charLength ? `(${charLength})` : "")
  }

  if (formEntries['default-value'])
    return `${formEntries['column-name']}${formEntries['data-type']}${formEntries['default-value']}${formEntries['constraints']}`;

  return `${formEntries['column-name']}${formEntries['data-type']}${formEntries['constraints']}`;
}

function generateQuery(formElement: HTMLFormElement) {
    let tableName = "";
    let columnDetails = "";

    for (let childNode of formElement.children) {
      if (childNode.nodeName === "INPUT" && (childNode as HTMLInputElement).name === "table-name") {
        tableName = (childNode as HTMLInputElement).value;
      }
      if (childNode.nodeName === "DIV") {
        if (columnDetails)
          columnDetails += ', ';
        columnDetails += getColumnDetails(childNode as HTMLDivElement)
      }
    }

    return [tableName, `CREATE TABLE IF NOT EXISTS ${escapeSQLCharacters(tableName)} (${columnDetails});`]
}

function numericParams() {
  return (
    <></>
  )
}

/*columns
  [name type default value] [constraints+]+
  [generated column]
table constraints

default values can be expressions that returns a value rather than being just a value
check constraints that evaluate to null are taken to be true*/


type defaultValTypes = "DEFAULT VALUE"|"GEN ALWAYS AS IDENT"|"GEN BY DEFAULT AS IDENT"|"GEN ALWAYS AS EXPR"

function DefaultValueDropDown({dataType} : {dataType: string}) {
  const [defaultValType, setDefaultValType] = useState<defaultValTypes>("DEFAULT VALUE")
  const [optionsVisible, setOptionsVisibility] = useState(true);
  const seqDataTypes = ["bigint", "smallint", "integer"]
  const idenBtnDisabled = !seqDataTypes.includes(dataType)

  const verboseText: {[key: string]: string} = {
    "DEFAULT VALUE": "DEFAULT VALUE",
    "GEN ALWAYS AS IDENT": "GENERATED ALWAYS AS IDENTITY",
    "GEN BY DEFAULT AS IDENT": "GENERATED BY DEFAULT AS IDENTITY",
    "GEN ALWAYS AS EXPR": "GENERATED ALWAYS AS EXPRESSION"
  }

  function updateDisplay(defValType: defaultValTypes) {
    setDefaultValType(defValType)
    setOptionsVisibility(!optionsVisible)
  }

  return (
    <div id="default-types-container">
      <div id="default-types-dropdown" className={optionsVisible ? "" : "hidden"}>
        <button onClick={() => setOptionsVisibility(!optionsVisible)}>{verboseText[defaultValType]}&darr;</button>
        <ul>
          <li><button onClick={() => updateDisplay("DEFAULT VALUE")}>DEFAULT VALUE</button></li>
          {/* Check the docs for what they mean by sequence options */}
          <li>
            <button onClick={() => updateDisplay("GEN ALWAYS AS IDENT")} disabled={idenBtnDisabled}>
              GENERATED ALWAYS AS IDENTITY
            </button>
          </li> 
          <li>
            <button onClick={() => updateDisplay("GEN BY DEFAULT AS IDENT")} disabled={idenBtnDisabled}>
              GENERATED BY DEFAULT AS IDENTITY
            </button>
          </li>
          <li><button onClick={() => updateDisplay("GEN ALWAYS AS EXPR")}>GENERATED ALWAYS AS expression</button></li>
        </ul>
      </div>
      {defaultValType === "DEFAULT VALUE" && (
        <>
          <label htmlFor="default-value">Default value:</label>
          <input type="text" name="default-value" id="default-value" />
        </>
      )}
      {defaultValType === "GEN ALWAYS AS EXPR" && (
        <>
          <label htmlFor="default-value">GENERATED ALWAYS AS expression</label>
          <input type="text" name="default-value" id="default-value" />
        </>
      )}
    </div>
  )
}


interface ConstraintInfo {
  id: string;
  name: string;
  type: string;
  expression: string; // if any
}

function generateId() {
  const alphanumeric = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ123456789'
  let id = ''
  for (let i=0; i<5; i++) {
    let randomIndex = Math.floor(Math.random() * alphanumeric.length)
    id += alphanumeric[randomIndex]  
  }
  return id
}

function ColumnConstraints() {
  // TODO: READ UP ON THE NOT VALID constraint
  const [constraints, setConstraints] = useState<ConstraintInfo[]>([]);
  const [errorMsg, setErrorMsg] = useState("")

  /*
    A column can't have more than one primary key, foreign key,
    A table can't have more than one primary key
  */
  function addConstraint() {
    setConstraints([...constraints, {id: generateId(), name: "", type: "unspecified", expression: ""}])
  }

  function validateAndUpdate(constraintType: string, targetDataIndex: number) {
    for (const info of constraints) {
      if (info.type !== constraintType) {
        continue
      }else if (constraintType === "PRIMARY KEY") {
        setErrorMsg("Table already has a primary key!")
        return
      }else if (constraintType === "FOREIGN KEY") {
        setErrorMsg("Column is already a foreign key!")
        return
      }else if (info.type.startsWith("UNIQUE") && constraintType.startsWith("UNIQUE")) {
        setErrorMsg("Column already has a unique constraint. Change that one or remove it")
      }
    }
    if (constraints[targetDataIndex].type !== constraintType)
      return;
    setConstraints(constraints.map((constraint, index) => {
      if (index === targetDataIndex) {
         return {...constraint, type: constraintType}; 
      }
      return constraint;
    }))
  }


  return (
    <section>
      {errorMsg && <p className="error">{errorMsg} <button onClick={() => setErrorMsg("")}>x</button></p>}
      {constraints.map((constraint, index) => {
        return (<div key={constraint.id}>
          <label>Constraint name</label>
          <input type="text" name="constraint-name" placeholder="constraint-name"/>
          <label>Constraint type</label>
          <select onChange={(event) => {validateAndUpdate(event.target.value.trim(), index)}}>
            <option>CHECK</option>
            <option>PRIMARY KEY</option>
            <option>UNIQUE NULLS DISTINCT</option>
            <option>UNIQUE NULLS NOT DISTINCT</option>
            <option>NOT NULL</option>
            <option>FOREIGN KEY</option>
            <option>EXCLUDE</option>
          </select>
          {constraint.type === "unspecified" && <span>Constraint hasn't been specified</span>}
          {constraint.type === "CHECK" && <input type="text" placeholder="check expression"/>}
          {constraint.type === "PRIMARY KEY" && <span>PRIMARY KEY</span>}
          {constraint.type.startsWith("UNIQUE") && <span>{constraint.type}</span>}
          {constraint.type === "FOREIGN KEY" && (<>
            <label>Referencing Column</label>
            <select><option>no data yet</option></select>
            <label>Referened Table</label>
            <select><option>no data yet</option></select>
            <label>Referenced Column</label>
            <select><option>no data yet</option></select>
            <label>ON DELETE</label>
            <input type="text" />
            <select>
              <option>NO ACTION</option>
              <option>RESTRICT</option>
              <option>CASCADE</option>
              <option>SET NULL</option> {/* It has optional parameters*/}
              <option>SET DEFAULT</option> {/* It has optional parameters*/}
            </select>
          </>)}
          {constraint.type === "EXCLUDE" && (<button disabled>Implement Later</button>)}
        </div>)
      })}
      <button onClick={addConstraint}>Add constraint</button>
    </section>
  )
}

function TableConstraints() {
  return (
    <section>
      <h2>Table Constraints</h2>
      <p>Unimplemented</p>
    </section>
  )
}

function ColumnDetailsForm({renderKey, removeColumn} : {renderKey: number, removeColumn: (key: number)=>void}) {
  const [dataType, setDataType] = useState("")

  const extraInputComponents = { 
    "character varying": <input max={10485760} type="number" name="char-length" placeholder="n"/>,
    "character": <input max={10485760} type="number" name="char-length" placeholder="n"/>,
    // warn users about negative scale not being portable and check if these are the proper max and min scales
    "numeric": <><input max={1000} min={-1000} type="number" name="precision"/><input max={1000} min={-1000} type="number" name="scale"/></>,
    // Get all the enum types first
  }

  return (
    <div>
    <label htmlFor="column-name"><b>Column name</b></label>
    <input type="text" name="column-name" id="column-name" required />
    <label htmlFor="data-type"><b>Data type</b></label>
    <select required id="data-type" name="data-type" value={dataType} onChange={(event) => setDataType(event.target.value)}>
      <DataTypeOptions/>
    </select>
    {extraInputComponents[dataType] || null}
    <DefaultValueDropDown dataType={dataType}/>
    <ColumnConstraints/>
    <TableConstraints/>
    <button>Add Constraints</button>

    <label htmlFor="constraints"><b>Constraints</b></label>
    
    <input type="text" name="constraints" id="constraints" />
    <label>No Inherit</label>
    <input type="checkbox"/>
    <button type="button" onClick={() => removeColumn(renderKey)}>remove</button>
    </div>
  )
}


function GeneralTableAttributes({visibility} : {visibility: "visible"|"hidden"|"collapse"}) {
  const [tempOptionsVisible, setTempOptionsVisible] = useState(false)
  return (
    <div style={{visibility: visibility}} className="form-section">
      <h2>Table Name:</h2>
      <input name="table-name" id="table-name" type="text" required />
      <label>Temporary</label>
      <input type="checkbox" name="temporary" onChange={(event)=>setTempOptionsVisible(event.target.checked)}/>
      <label>Unlogged</label>
      <input type="checkbox" name="unlogged"/>
      {/*<select disabled>
        <option>Local</option>
        <option>Global</option>
      </select>*/}
      {tempOptionsVisible && (
        <div>
          <label>ON COMMIT</label>
          <select>
            <option>PRESERVE ROWS</option>
            <option>DELETE ROWS</option>
            <option>DROP</option>
          </select>
        </div>
      )}
      <label>INHERITS</label>
      <select><option>No Data yet</option></select>
      <label>LIKE TABLE</label>
      <select><option>No data yet</option></select>
      <label>including</label>
      <select>
        <option>INCLUDING ALL</option>
        <option>INCLUDING COMPRESSION</option>
        <option>INCLUDING CONSTRAINTS</option>
        <option>INCLUDING COMMENTS</option>
        <option>INCLUDING GENERATED</option>
        <option>INCLUDING IDENTITY</option>
        <option>INCLUDING INDEXES</option>
        <option>INCLUDING STORAGE</option>
        <option>INCLUDING STATISTICS</option>
      </select>
      <label>PARTITION OF</label>
      <select><option>no data yet</option></select>
      <label>PARTITIONED BY</label>
      <select>
        <option>RANGE</option>
        <option>LIST</option>
        <option>HASH</option>
      </select>
    </div>
  )
}

function ColumnDetails({visibility} : {visibility: "visible"|"hidden"|"collapse"}) {
  const [columnKeys, setColumnKeys] = useState<number[]>([]); // free keys for rendering column components
  const freeColumnKeys = useRef([1]);

  function addNewColumn() {
    let newColumnKeys:number[] = [...columnKeys, freeColumnKeys.current.pop() as number]

    if (freeColumnKeys.current.length === 0)
      freeColumnKeys.current.push(newColumnKeys.length+1);
    setColumnKeys(newColumnKeys);
  }

  function removeColumn(renderKey: number) {
      setColumnKeys(columnKeys.filter((key) => key !== renderKey))
      freeColumnKeys.current.push(renderKey);
  }

  return (
    <div style={{visibility: visibility}} className="form-section">
      <h3>Columns</h3>
      {columnKeys.map(key => <ColumnDetailsForm key={key} renderKey={key} removeColumn={removeColumn}/>)}
      <button type="button" onClick={() => addNewColumn()}>Add Column</button>
    </div>
  )
}


export function CreateTable({targetDb}: {targetDb: string}) {
  const [display, setDisplay] = useState<"general"|"columns"|"sql">("general")
  const formRef = useRef<HTMLFormElement>(null);
  const setDisplayData = useContext(DataDisplayFn)

  function createTable(event) {
    event.preventDefault();
    const [newTableName, query] = generateQuery(formRef.current as HTMLFormElement);
    console.log(query);
    fetch("http://localhost:4900/mutate-dbData", {
      credentials: "include",
      headers: {"Content-Type": "application/json"},
      method: "POST",
      body: JSON.stringify({targetDb, query, queryType: "create"}) 
    })
    .then(response => response.json())
    .then(responseBody => {
      if (responseBody.errorMsg) {
        alert(`${responseBody.errorMsg} Please try again!`)
      }else {
        alert("Successful")
        setDisplayData({type: "table-info", data: {tableName: newTableName, targetDb}}) // fix schema bug, Infact the table should be created with the qualified name
      }
    })
  }

  return (
    <form ref={formRef} onSubmit={createTable} id="create-form">
      <div id="table-attr-selection">
        <button type="button" onClick={() => setDisplay("general")}>General</button>
        <button type="button" onClick={() => setDisplay("columns")}>Column Atributes</button>
        <button type="button" onClick={() => setDisplay("sql")}>SQL</button>
      </div>
      <GeneralTableAttributes visibility={display === "general" ? "visible" : "hidden"}/>
      <ColumnDetails visibility={display === "columns" ? "visible" : "hidden"}/>
      <pre style={{visibility: display === "sql" ? "visible" : "hidden"}} className="form-section"></pre>
      <button type="submit" disabled>Create Table</button>
    </form>
  )
}